<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>nock files</title>
<style>
  /* ultra-stark */
  body { font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:20px auto; max-width:900px; color:#111; background:#fff; }
  h2 { margin:0; font-size:18px; }
  .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
  input, button { font:inherit; border:1px solid #ccc; padding:4px 6px; background:#fff; color:#111; }
  input[type=file]{ padding:0; }
  #msg { font-size:13px; margin:4px 0 10px; white-space:pre-wrap; color:#444; }
  table { width:100%; border-collapse:collapse; font-size:13px; }
  th, td { border-bottom:1px solid #ddd; padding:6px 6px; text-align:left; }
  td.name { font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; }
  td.size, td.time { white-space:nowrap; }
  td.actions a { color:#06c; text-decoration:none; }
  td.actions a:hover { text-decoration:underline; }
  footer { margin-top:12px; font-size:12px; color:#666; }
  .hidden { display:none; }
  .invalid { outline:1px solid #c33; }
  .meta { font-size:13px; color:#444; margin:8px 0 12px; }
  .meta code { background:#f7f7f7; padding:2px 4px; border:1px solid #e5e5e5; }
</style>
</head>
<body>

<!-- SOFT GATE -->
<section id="gate">
  <div class="row"><h2 style="flex:1">nock files</h2></div>
  <div class="row">
    <input id="gateToken" type="password" placeholder="token" style="flex:1" />
    <button id="gateBtn">Enter</button>
  </div>
  <div id="gateMsg" style="font-size:13px;margin-top:6px;"></div>
</section>

<!-- APP -->
<section id="app" class="hidden">
  <div id="meta" class="meta"></div>

  <section>
    <details open>
      <summary>Upload</summary>
      <div class="row" style="margin-top:4px">
        <input id="uploadPath" style="flex:1" placeholder="priv/…/file.txt" />
        <input id="fileInput" type="file" />
        <button id="uploadBtn">PUT</button>
      </div>
    </details>
  </section>

  <section>
    <h4>All files you can read</h4>
    <div id="msg"></div>
    <table>
      <thead>
        <tr>
          <th class="name">/full/path/filename</th>
          <th class="size">Size</th>
          <th class="time">Uploaded</th>
          <th class="actions">Actions</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
  </section>

  <footer>API: <code>https://api.nock.ezpz.sh</code></footer>
</section>

<script>
const API = 'https://api.nock.ezpz.sh';
const $ = id => document.getElementById(id);

/* ---------- token + gate ---------- */
const getToken = () => (localStorage.getItem('token') || '').trim();
const setToken = (t) => localStorage.setItem('token', (t||'').trim());

async function verifyToken(t){
  const res = await fetch(`${API}/auth/verify`, { headers: t ? { Authorization: 'Bearer ' + t } : {} });
  if (!res.ok) return null;
  try { return await res.json(); } catch { return null; } // { roles, prefixes, writePrefixes }
}

function normPrefix(p){ return p && !p.endsWith('/') ? p + '/' : p; }
function authHeaders(){ const t=getToken(); return t ? { Authorization: 'Bearer ' + t } : {}; }
function setMsg(txt, ok=true){ const el=$('msg'); el.textContent = txt || ''; el.style.color = ok ? '#444' : '#c33'; }

function canWriteKey(key, writePrefixes) {
  return (writePrefixes || []).some(pref => key.startsWith(pref));
}

async function listAll(prefixes){
  const reqs = (prefixes || []).map(p => {
    const url = new URL(API + '/ls');
    url.searchParams.set('prefix', normPrefix(p));
    return fetch(url, { headers: authHeaders() }).then(async r => {
      if (!r.ok) throw new Error(`ls ${p} → ${r.status}`);
      return r.json(); // { prefix, objects }
    });
  });
  const results = await Promise.all(reqs);
  const objects = results.flatMap(r => r.objects || []);
  // stable sort by full key
  objects.sort((a,b) => a.key.localeCompare(b.key));
  return objects;
}

function renderWritable(writePrefixes){
  const el = $('meta');
  if (!writePrefixes || !writePrefixes.length) {
    el.textContent = 'Writable: none';
    return;
  }
  el.innerHTML = `Writable: ${writePrefixes.map(p => `<code>${p}</code>`).join(' ')}`;
  // convenience: hint the uploadPath placeholder
  const up = $('uploadPath');
  if (up && !up.value) up.placeholder = `${writePrefixes[0]}file.txt`;
}

function buildGetHref(key, token) {
  if (key.startsWith('pub/')) {
    const rel = key.slice('pub/'.length);
    return `${API}/pub/${rel.split('/').map(encodeURIComponent).join('/')}`;
  }
  if (key.startsWith('priv/')) {
    const rel = key.slice('priv/'.length);
    return `${API}/priv/${rel.split('/').map(encodeURIComponent).join('/')}?key=${encodeURIComponent(token)}`;
  }
  // fallback: treat as private path fragment
  return `${API}/priv/${key.split('/').map(encodeURIComponent).join('/')}?key=${encodeURIComponent(token)}`;
}

function renderTable(objects, writePrefixes){
  const rows = $('rows'); rows.innerHTML = '';
  const token = getToken();
  if (!objects.length) { setMsg('No files.'); return; }
  setMsg('');
  for (const o of objects) {
    const full = o.key; // show full path
    const href = buildGetHref(full, token);
    const delAllowed = full.startsWith('priv/') && canWriteKey(full, writePrefixes);
    const delBtn = delAllowed ? ` <button data-key="${full}">DEL</button>` : '';
    rows.insertAdjacentHTML('beforeend',
      `<tr>
        <td class="name">${full}</td>
        <td class="size">${o.size}</td>
        <td class="time">${new Date(o.uploaded).toLocaleString()}</td>
        <td class="actions"><a href="${href}" target="${full.startsWith('priv/') ? '_blank' : ''}">GET</a>${delBtn}</td>
      </tr>`);
  }

  // wire deletes for allowed rows only
  document.querySelectorAll('button[data-key]').forEach(btn => btn.onclick = async () => {
    if (!confirm('Delete ' + btn.dataset.key + '?')) return;
    const path = btn.dataset.key.replace(/^priv\//, '');
    const enc = path.split('/').map(encodeURIComponent).join('/');
    const resDel = await fetch(`${API}/priv/${enc}`, { method:'DELETE', headers: authHeaders() });
    if (!resDel.ok) setMsg('Delete failed: ' + (await resDel.text()), false);
    else {
      // optimistically remove row
      btn.closest('tr')?.remove();
    }
  });
}

async function enterWithToken(t){
  const info = await verifyToken(t);
  if (!info) return false;
  setToken(t);
  $('gate').classList.add('hidden');
  $('app').classList.remove('hidden');

  // show writable list
  renderWritable(info.writePrefixes || []);

  // fetch all readable prefixes, flat
  try {
    const objs = await listAll(info.prefixes || []);
    renderTable(objs, info.writePrefixes || []);
  } catch (e) {
    setMsg('List error: ' + (e?.message || e), false);
  }
  return true;
}

$('gateBtn').onclick = async () => {
  const t = $('gateToken').value.trim();
  const ok = await enterWithToken(t);
  $('gateToken').classList.toggle('invalid', !ok);
  $('gateMsg').textContent = ok ? '' : 'Invalid token';
};

// auto-try saved token
(async () => {
  const saved = getToken();
  if (saved) await enterWithToken(saved);
})();

/* ---------- upload ---------- */
$('uploadBtn').onclick = async () => {
  const file = $('fileInput').files[0];
  const target = $('uploadPath').value.trim();
  if (!file || !target) { alert('Pick file and target path'); return; }
  const rel = target.replace(/^priv\//, '');
  try {
    const enc = rel.split('/').map(encodeURIComponent).join('/');
    const res = await fetch(`${API}/priv/${enc}`, {
      method:'PUT',
      body:file,
      headers:{ ...authHeaders(), 'Content-Type': file.type || 'application/octet-stream' }
    });
    if (!res.ok) setMsg('Upload failed: ' + (await res.text()), false);
    else setMsg('Uploaded');
  } catch(e) { setMsg('Upload error: ' + (e?.message || e), false); }
};
</script>
</body>
</html>
